from sklearn.preprocessing import OneHotEncoder
import numpy as np, pandas as pd, os, gc, chardet
from sklearn.preprocessing import LabelEncoder
from sampleDataByRow import types

UIDs = ['AVProductStatesIdentifier', 'Census_ProcessorModelIdentifier', 'MachineIdentifier', 'DefaultBrowsersIdentifier', 'CountryIdentifier', 'GeoNameIdentifier', 'LocaleEnglishNameIdentifier', 'Census_OEMNameIdentifier']

NUMERICAL_COLS = ['Census_TotalPhysicalRAM',  'Census_InternalBatteryNumberOfCharges']

BOOLEAN_COLS = ['Wdft_IsGamer', 'Census_IsAlwaysOnAlwaysConnectedCapable', 'Census_IsTouchEnabled', 'Census_IsPenCapable', 'AVProductsEnabled', 'Census_HasOpticalDiskDrive', 'IsSxsPassiveMode']

LABEL_ENCODING = []

FREQUENCYENCODING_COLS = ['Census_FirmwareManufacturerIdentifier', 'CountryIdentifier', 'CityIdentifier', 'EngineVersion', 'AppVersion', 'ProductName'] # [, , 'AvSigVersion', 'Census_OSVersion',

ONEHOTENCODING_COLS = ['RtpStateBitfield', 'AVProductsInstalled', 'Processor',
'OsBuild', 'OsSuite', 'SmartScreen', 'Census_MDC2FormFactor',
'Census_ProcessorCoreCount', 'Census_PrimaryDiskTypeName', 'Census_ChassisTypeName',
'Census_PowerPlatformRoleName', 'Census_OSEdition', 'Census_OSInstallLanguageIdentifier',
'Census_GenuineStateName', 'Census_ActivationChannel', 'Wdft_RegionIdentifier',
'Census_ProcessorCoreCount']

TARGET = ['HasDetections']


SCREEN_DENSITY_FEATURE = 'ScreenDensityFeature'


def screenDensityFeature(df: pd.DataFrame):
    diogonalSize = df['Census_InternalPrimaryDiagonalDisplaySizeInInches']
    horizontalRes = df['Census_InternalPrimaryDisplayResolutionHorizontal']
    VerticalRes = df['Census_InternalPrimaryDisplayResolutionVertical']
    df[SCREEN_DENSITY_FEATURE] = (horizontalRes * VerticalRes) / diogonalSize
    print('Created feature for density')
    return df[SCREEN_DENSITY_FEATURE]

def oneHotEncode(df, columnName, categories):
    # Ensure the column is a string
    df[columnName] = df[columnName].astype(str)

    # Initialize OneHotEncoder with the precalculated categories
    ohe = OneHotEncoder(categories=[categories[columnName]], handle_unknown='ignore')

    # Transform to OneHot encoding
    oheTransform = ohe.fit_transform(df[[columnName]]).toarray()

    # Add the new columns
    columns = [f"{columnName}_{cat}" for cat in categories[columnName]]

    ohe_df = pd.DataFrame(oheTransform, columns=columns, index=df.index)

    print(f"Creating {len(columns)} columns for {columnName} using one hot encoding.")
    return ohe_df

def normalizeNumericalValCol(df, columnName):
    df[columnName] = df[columnName] / df[columnName].abs().max()
    return df[columnName]

def freqEncode(df, columnName, categories, frequency_map=None):
    if frequency_map is None:
        frequency_map = {k: v for v, k in enumerate(categories[columnName])}
    freq_encoded_column = df[columnName].map(frequency_map)
    return freq_encoded_column

def labelEncode(df, columnName, categories):
    # won't accept nan values
    label_encoder = LabelEncoder()
    label_encoder.fit(categories[columnName])
    encoded_column = label_encoder.transform(df[columnName])
    return pd.Series(encoded_column, index=df.index, name=f"{columnName}")

def precalculate_unique_values(path):
    categorical_cols = ONEHOTENCODING_COLS + LABEL_ENCODING + FREQUENCYENCODING_COLS
    unique_values = {col: set() for col in categorical_cols}
    for col in categorical_cols:
        unique_values[col] = set(pd.read_csv(path, usecols=[col])[col].dropna().unique())
    return {col: list(values) for col, values in unique_values.items()}




def processData(path, categories, chunksize=10000, output='data.csv', testing=False):
    df = pd.read_csv(path, chunksize=chunksize, low_memory=False, dtype=types)

    count = 0
    for chunk in df:
        #chunk.fillna(0.0, inplace=True)

        processed_chunk = pd.DataFrame(index=chunk.index)

        for col in ONEHOTENCODING_COLS:
            processed_chunk = pd.concat([processed_chunk, oneHotEncode(chunk, col, categories)], axis=1)


        for col in FREQUENCYENCODING_COLS:
            print(f"Freq encoding column: {col}")
            processed_chunk = pd.concat([processed_chunk, freqEncode(chunk, col, categories)], axis=1)

        for col in NUMERICAL_COLS:
            print(f"Normalizing column: {col}")
            processed_chunk = pd.concat([processed_chunk, normalizeNumericalValCol(chunk, col)], axis=1)


        for col in LABEL_ENCODING:
            print(f"Label Encoding column: {col}")
            processed_chunk = pd.concat([processed_chunk, labelEncode(chunk, col, categories)], axis=1)

        for col in UIDs:
            continue


        # Screen density
        processed_chunk = pd.concat([processed_chunk, screenDensityFeature(chunk)], axis=1)

        if not testing:
            processed_chunk['HasDetections'] = chunk['HasDetections']

        if count == 0:
            processed_chunk.to_csv(output, mode='w', header=True, index=False)
        else:
            processed_chunk.to_csv(output, mode='a', header=False, index=False)

        gc.collect()
        count += 1
        print("Chunks processed: ", count)


def processAll(inputFile, outputFile):
    categories = precalculate_unique_values(inputFile)
    processData(inputFile, categories=categories, chunksize=100000, output=outputFile)

def main():
    path = 'sample.csv'
    outputPath = 'data.csv'
    categories = precalculate_unique_values(path)
    chunksize = 100000
    processData(path=path, categories=categories, chunksize=chunksize, output=outputPath, )

if __name__ == '__main__':
    main()
