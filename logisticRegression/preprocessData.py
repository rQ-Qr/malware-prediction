from sklearn.preprocessing import OneHotEncoder
import numpy as np, pandas as pd, os, gc, chardet
from sklearn.preprocessing import LabelEncoder

UIDs = ['AVProductStatesIdentifier', 'Census_ProcessorModelIdentifier', 'MachineIdentifier', 'DefaultBrowsersIdentifier', 'CountryIdentifier', 'GeoNameIdentifier', 'LocaleEnglishNameIdentifier']

NUMERICAL_COLS = ['Census_TotalPhysicalRAM', 'Census_InternalPrimaryDiagonalDisplaySizeInInches', 'Census_InternalBatteryNumberOfCharges', 'Census_InternalPrimaryDisplayResolutionHorizontal',  'Census_PrimaryDiskTotalCapacity', 'Census_InternalPrimaryDisplayResolutionVertical']

BOOLEAN_COLS = ['Wdft_IsGamer', 'Census_IsAlwaysOnAlwaysConnectedCapable', 'Census_IsTouchEnabled', 'Census_IsPenCapable', 'AVProductsEnabled', 'Census_HasOpticalDiskDrive', 'IsSxsPassiveMode']

LABEL_ENCODING = [] # ['CountryIdentifier', 'CityIdentifier', 'Wdft_RegionIdentifier', 'Census_OSInstallLanguageIdentifier', 'Census_OSEdition', 'OsBuild']

FREQUENCYENCODING_COLS = ['Census_FirmwareManufacturerIdentifier'] # ['EngineVersion', 'AppVersion', 'AvSigVersion', 'Census_OSVersion', 'Processor', 'Census_OEMNameIdentifier', 'Census_FirmwareManufacturerIdentifier', 'DefaultBrowsersIdentifier', 'LocaleEnglishNameIdentifier', 'GeoNameIdentifier', 'ProductName']

ONEHOTENCODING_COLS = ['RtpStateBitfield', 'AVProductsInstalled',                                                                                                       
'Processor', 'OsBuild', 'OsSuite', 'SmartScreen', 'Census_MDC2FormFactor',
'Census_ProcessorCoreCount', 'Census_PrimaryDiskTypeName', 'Census_ChassisTypeName',
'Census_PowerPlatformRoleName', 'Census_InternalBatteryType',
'Census_OSEdition', 'Census_OSInstallLanguageIdentifier', 'Census_GenuineStateName', 'Census_ActivationChannel',
'Wdft_RegionIdentifier', 'AVProductsInstalled', 'Census_ProcessorCoreCount'] + BOOLEAN_COLS

target = ['HasDetections']





def oneHotEncode(df, columnName):

    # parse as string
    df[columnName] = df[columnName].astype(str)
    
    ohe = OneHotEncoder(handle_unknown='ignore')

    # transform to One hot encoding
    oheTransform = ohe.fit_transform(df[[columnName]]).toarray()
    
    # add the new columns
    columns = [f"{columnName}_{cat}" for cat in ohe.categories_[0]]

    ohe_df = pd.DataFrame(oheTransform, columns=columns, index=df.index)

    print(f"Creating {len(columns)} for column {columnName} using one hot encoding.")
    return ohe_df

def normalizeNumericalValues(df, columnName):
    df[columnName] = df[columnName]  / df[columnName].abs().max()
    return df[columnName]

# frequency encoding such that each category has a different label based on frequnecy
def freqEncode(df, columnName):
    frequency_map = df[columnName].value_counts().to_dict()
    freq_encoded_column = df[columnName].map(frequency_map)
    return freq_encoded_column

def labelEncode(df, columnName):
    label_encoder = LabelEncoder()
    encoded_column = label_encoder.fit_transform(df[columnName])
    return pd.Series(encoded_column, index=df.index, name=f"{columnName}")


def processData(path, chunksize=10000, output='data.csv'):
    df = pd.read_csv(path, chunksize=chunksize, low_memory=False)

    count = 0

    for chunk in df:
        chunk.fillna(0.0, inplace=True)

        processed_chunk = pd.DataFrame(index=chunk.index)

        for col in ONEHOTENCODING_COLS:
            processed_chunk = pd.concat([processed_chunk, oneHotEncode(chunk, col)], axis=1)
            

        for col in FREQUENCYENCODING_COLS:
            processed_chunk = pd.concat([processed_chunk, freqEncode(chunk, col)], axis=1)
         

        for col in NUMERICAL_COLS:
            print(f"Processing column: {col}")
            processed_chunk = pd.concat([processed_chunk, normalizeNumericalValues(chunk, col)], axis=1)


        for col in LABEL_ENCODING:
            processed_chunk = pd.concat([processed_chunk, labelEncode(chunk, col)], axis=1)
            

        for col in UIDs:
            continue

        processed_chunk['HasDetections'] = chunk['HasDetections']

        if count == 0:
            processed_chunk.to_csv(output, mode='w', header=True, index=False)
        else:
            processed_chunk.to_csv(output, mode='a', header=False, index=False)

        count += 1
        print("Chunks processed: ", count)


def main():
    path = 'sample.csv'
    outputPath = 'data.csv'
    # left at a large number, given that one hot encoder is not being overused.
    chunksize = 999999999

    processData(path, chunksize, outputPath)

if __name__ == '__main__':
    main()
